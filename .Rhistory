filter(is.na(sale_online)) |>
filter(!is.na(price)) |>
filter(!is.na(price_online))
# drop errors (+1000 dollars)
pd <- pd |> filter(price < 1000)
# creating diff variable
pd <- pd |> mutate(diff = price_online - price)
# Check the main descriptives
modelsummary::datasummary(diff ~ Mean + SD + Min + Max + Median + Max, data = pd)
# plotting online-offline price differences
p1 <- ggplot(data = pd, aes(diff)) +
geom_histogram(
binwidth = 5, boundary = 0, closed = "left",
fill = color[1], size = 0.25, alpha = 0.8, show.legend = F, na.rm = TRUE
) +
labs(x = "Online - offline price difference (US dollars)", y = "Frequency") +
theme_bg() +
scale_x_continuous(limits = c(-420, 420), breaks = seq(-400, 420, by = 100)) +
scale_y_continuous(limits = c(0, 6000), breaks = seq(0, 6000, by = 1000), expand = c(0.01, 0.01)) +
geom_segment(aes(x = 300, y = 500, xend = 415, yend = 20), arrow = arrow(length = unit(0.1, "cm"))) +
annotate("text", x = 300, y = 700, label = "max value= 415", size = 2.5) +
geom_segment(aes(x = -280, y = 500, xend = -380, yend = 20), arrow = arrow(length = unit(0.1, "cm"))) +
annotate("text", x = -300, y = 700, label = "min value= -380", size = 2.5)
## By default, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(
echo = TRUE, message = FALSE, warning = FALSE
)
# CONFIG
user_name <- "fernandomillanvillalobos" # your Git username (only needed if
# you want to deploy to GH pages)
project_name <- "dabep" # adapt!
package_date <- "2021-11-01" # date of the CRAN snapshot that
# the checkpoint package uses
r_version <- "4.1.2" # R-Version to use
options(Ncpus = 4) # use 4 cores for parallelized installation of packages
if (r_version != paste0(version$major, ".", version$minor)) {
stop("ERROR: specified R version does not match currently used.")
}
detach_all_packages <- function() {
basic_packages_blank <- c(
"stats",
"graphics",
"grDevices",
"utils",
"hotels_rawsets",
"methods",
"base"
)
basic_packages <- paste("package:", basic_packages_blank, sep = "")
package_list <- search()[
ifelse(unlist(gregexpr("package:", search())) == 1, TRUE, FALSE)
]
package_list <- setdiff(package_list, basic_packages)
if (length(package_list) > 0) {
for (package in package_list) {
detach(package, character.only = TRUE, unload = TRUE)
print(paste("package ", package, " detached", sep = ""))
}
}
}
detach_all_packages()
# this allows multiple persons to use the same RMarkdown
# without adjusting the working directory by themselves all the time
source("scripts/csf.R")
path_to_wd <- csf() # if this - for some reason - does not work,
# replace with a hardcoded path, like so: "~/projects/rddj-template/analysis/"
if (is.null(path_to_wd) | !dir.exists(path_to_wd)) {
print("WARNING: No working directory specified for current user")
} else {
setwd(path_to_wd)
}
# suppress scientific notation
options(scipen = 999)
# suppress summarise info
options(dplyr.summarise.inform = FALSE)
# unload global rstudioapi and knitr again to avoid conflicts with checkpoint
# this is only necessary if executed within RStudio
# outside of RStudio, namely in the knit.sh script, this causes RMarkdown
# rendering to fail, thus should not be executed there
if (Sys.getenv("RSTUDIO") == "1") {
detach_all_packages()
}
# from https://mran.revolutionanalytics.com/web/packages/\
# checkpoint/vignettes/using-checkpoint-with-knitr.html
# if you don't need a package, remove it from here (commenting not sufficient)
# tidyverse: see https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/
cat("
library(rstudioapi)
library(tidyverse, warn.conflicts = FALSE) # ggplot2, dplyr, tidyr, readr, purrr, tibble, magrittr, readxl
library(scales) # scales for ggplot2
library(jsonlite) # json
library(lintr) # code linting
library(sf)
library(rmarkdown)
library(data.table)
library(cowplot) # theme
library(extrafont)
library(waldo) # compare
library(psych) # some useful funs
library(ggrepel)
library(skimr)
library(haven)
library(Hmisc)
library(desc)
library(reshape2)
library(pastecs)
library(patchwork)
library(xtable)
library(reticulate)
library(binsreg)
library(boot)
library(modelsummary)
library(viridis)
library(grid)
library(janitor)", # names
file = "manifest.R"
)
# library(sf)
# if checkpoint is not yet installed, install it (for people using this
# system for the first time)
if (!require(checkpoint)) {
if (!require(devtools)) {
install.packages("devtools", repos = "http://cran.us.r-project.org")
require(devtools)
}
devtools::install_github("RevolutionAnalytics/checkpoint",
ref = "v0.3.2", # could be adapted later,
# as of now (beginning of July 2017
# this is the current release on CRAN)
repos = "http://cran.us.r-project.org"
)
require(checkpoint)
}
# nolint start
if (!dir.exists("~/.checkpoint")) {
dir.create("~/.checkpoint")
}
# nolint end
# install packages for the specified CRAN snapshot date
checkpoint(
snapshot_date = package_date,
project = path_to_wd,
verbose = T,
scanForPackages = T,
use.knitr = F,
R.version = r_version
)
rm(package_date)
source("manifest.R")
install.packages("sf")
source("manifest.R")
unlink("manifest.R")
sessionInfo()
# if you want to outsource logic to other script files, see README for
# further information
# Load all visualizations functions as separate scripts
knitr::read_chunk("scripts/dviz.supp.R")
source("scripts/dviz.supp.R")
knitr::read_chunk("scripts/themes.R")
source("scripts/themes.R")
knitr::read_chunk("scripts/plot_grid.R")
source("scripts/plot_grid.R")
knitr::read_chunk("scripts/align_legend.R")
source("scripts/align_legend.R")
knitr::read_chunk("scripts/label_log10.R")
source("scripts/label_log10.R")
knitr::read_chunk("scripts/outliers.R")
source("scripts/outliers.R")
knitr::read_chunk("scripts/theme_bg.R")
source("scripts/theme_bg.R")
# CASE STUDY: Comparing Online and Offline Prices: Testing the Difference
pd <- read.csv("input/online_offline_ALL_clean.csv")
# filter the data
pd <- pd |>
filter(COUNTRY == "USA") |>
filter(PRICETYPE == "Regular Price") |>
filter(is.na(sale_online)) |>
filter(!is.na(price)) |>
filter(!is.na(price_online))
# drop errors (+1000 dollars)
pd <- pd |> filter(price < 1000)
# creating diff variable
pd <- pd |> mutate(diff = price_online - price)
# Check the main descriptives
modelsummary::datasummary(diff ~ Mean + SD + Min + Max + Median + Max, data = pd)
# plotting online-offline price differences
p1 <- ggplot(data = pd, aes(diff)) +
geom_histogram(
binwidth = 5, boundary = 0, closed = "left",
fill = color[1], size = 0.25, alpha = 0.8, show.legend = F, na.rm = TRUE
) +
labs(x = "Online - offline price difference (US dollars)", y = "Frequency") +
theme_bg() +
scale_x_continuous(limits = c(-420, 420), breaks = seq(-400, 420, by = 100)) +
scale_y_continuous(limits = c(0, 6000), breaks = seq(0, 6000, by = 1000), expand = c(0.01, 0.01)) +
geom_segment(aes(x = 300, y = 500, xend = 415, yend = 20), arrow = arrow(length = unit(0.1, "cm"))) +
annotate("text", x = 300, y = 700, label = "max value= 415", size = 2.5) +
geom_segment(aes(x = -280, y = 500, xend = -380, yend = 20), arrow = arrow(length = unit(0.1, "cm"))) +
annotate("text", x = -300, y = 700, label = "min value= -380", size = 2.5)
p1
# 4.99999 not 5 -- needed because of data imported from stata may be stored wierdly.
# pd1 <- subset(pd, abs(pd$diff) < 4.999999)
# Hmisc::describe(pd1$diff)
# plotting online-offline price differences (+-5 dollar price difference)
p2 <- ggplot(data = pd, aes(diff)) +
geom_histogram(
binwidth = 0.5, boundary = -0, closed = "left",
color = color.outline, fill = color[1], size = 0.25, alpha = 0.8, show.legend = F, na.rm = TRUE
) +
labs(x = "Online - offline price difference (US dollars)", y = "Frequency") +
theme_bg() +
expand_limits(x = 0.01, y = 0.01) +
scale_x_continuous(limits = c(-5, 5), breaks = seq(-5, 5, by = 1)) +
scale_y_continuous(expand = c(0.00, 0.00), limits = c(0, 5000), breaks = seq(0, 5000, by = 1000))
p2
p1 | p2
# CASE STUDY: Comparing Online and Offline Prices: Testing the Difference
t.test(pd$diff, mu = 0)
# CASE STUDY: Comparing Online and Offline Prices: Testing the Difference
# calculating multiple hypotheses for each retailer in the data (16)
spd <- split(pd, pd$retailer, drop = FALSE)
out <- vector("list", length = length(spd))
out <- lapply(1:length(spd), function(x) out[[x]] <- t.test(spd[[x]]$diff, mu = 0))
out
# creating a table with the 16 p-values if we carry out each test one by one
table_out <- pd |>
group_by(retailer) |>
group_modify(~ tidy(t.test(.x$diff)))
table_out <- table_out |>
dplyr::select(retailer, estimate, p.value)
table_out
# CASE STUDY: Finding a Good Deal among Hotels with Simple Regression
hotels <- read_csv("input/hotels-vienna.csv")
# Apply filters:  3-4 stars, Vienna actual, without extreme value
hotels <- hotels |>
filter(accommodation_type == "Hotel") |>
filter(city_actual == "Vienna") |>
filter(stars >= 3 & stars <= 4) |>
filter(!is.na(stars)) |>
filter(price <= 600)
# summary statistics on price
descr_price <- hotels |>
dplyr::select(price) |>
dplyr::summarize(
mean = mean(price),
sd = sd(price),
min = min(price),
max = max(price),
p50 = quantile(price, .50),
p95 = quantile(price, .95),
n = length(price)
)
descr_price
# summary statistics on distance
descr_dist <- hotels |>
dplyr::select(distance) |>
dplyr::summarize(mean=mean(distance),
sd=sd(distance),
min=min(distance),
max=max(distance),
p50=quantile(distance,.50),
p95=quantile(distance,.95),
n=length(distance))
descr_dist
# REGRESSION 1: CLOSE VS FAR REGRESSION WITH BINARY DISTANCE
hotels <- hotels |> mutate(dist2 = as.numeric(distance >= 2))
dist2 <- hotels |>
group_by(dist2) |>
dplyr::summarize(Eprice_cat2 = mean(price))
hotels <- left_join(hotels, dist2)
hotels <- hotels |> mutate(dist2 = recode(dist2, `0` = "Close", `1` = "Far"))
hotels |>
group_by(dist2) |>
dplyr::summarize(
mean_dist = mean(distance),
sd_dist = sd(distance),
min_dist = min(distance),
max_dist = max(distance),
mean_price = mean(price),
sd_price = sd(price),
min_price = min(price),
max_price = max(price),
N = n()
)
# plotting the regression analysis (2 bins) with bin scatters
p1 <- ggplot(data = hotels) +
geom_point(aes(x = dist2, y = Eprice_cat2),
size = 2.5, color = color[1], fill = color[1], shape = 21, alpha = 0.4, na.rm = T
) +
geom_text(aes(x = dist2, y = Eprice_cat2, label = round(Eprice_cat2)), hjust = -0.8, vjust = 0, color = "black", size = 3) +
scale_y_continuous(expand = c(0.01, 0.01), limits = c(0, 400), breaks = seq(0, 400, by = 50)) +
expand_limits(y = 0.01) +
scale_x_discrete() +
labs(x = "Distance to city center (categories)", y = "Average price (US dollars)") +
theme_bg()
p1
# plotting the box plot
p2 <- ggplot(data = hotels, aes(x = dist2, y = price)) +
stat_boxplot(aes(group = dist2), geom = "errorbar", width = 0.25, color = viridis(2, begin = 0.3, end = 0.7), size = 0.5, na.rm = T) +
geom_boxplot(aes(group = dist2), color = viridis(2, begin = 0.3, end = 0.7), fill = viridis(2, begin = 0.3, end = 0.7), size = 0.5, width = 0.5, alpha = 0.3, na.rm = T, outlier.shape = NA) +
geom_jitter(aes(color = dist2), position = position_jitter(0.1), size = 0.5, show.legend = F, na.rm = T) +
labs(x = "Distance to city center (categories)", y = "Price (US dollars)") +
scale_y_continuous(expand = c(0.01, 0.01), limits = c(0, 400), breaks = seq(0, 400, 50)) +
expand_limits(y = 0.01) +
scale_color_viridis(discrete = TRUE, option = "D", begin = 0.3, end = 0.7) +
theme_bg()
p2
p1 | p2
### REGRESSION 2: 4 DISTANCE CATEGORIES
hotels <- hotels |> mutate(dist4 = 0.5 + 1 * as.numeric(hotels$distance >= 1) + 1 * as.numeric(hotels$distance >= 2) + 2.5 * as.numeric(hotels$distance >= 3))
dist4 <- hotels |>
group_by(dist4) |>
dplyr::summarize(Eprice_cat4 = mean(price))
hotels <- left_join(hotels, dist4)
hotels |>
group_by(dist4) |>
dplyr::summarize(
mean_dist = mean(distance),
sd_dist = sd(distance),
min_dist = min(distance),
max_dist = max(distance),
mean_price = mean(price),
sd_price = sd(price),
min_price = min(price),
max_price = max(price),
N = n()
)
# plotting the regression analysis (4 bins) with bin scatters
p3 <- ggplot(data = hotels) +
geom_point(aes(x = dist4, y = Eprice_cat4),
size = 2.5, color = color[1], fill = color[1], shape = 21, alpha = 0.4, na.rm = T
) +
geom_text(aes(x = dist4, y = Eprice_cat4, label = round(Eprice_cat4)), hjust = -0.6, vjust = 0, color = "black", size = 3) +
expand_limits(x = 0.01, y = 0.01) +
coord_cartesian(xlim = c(0, 7), ylim = c(0, 400)) +
scale_y_continuous(expand = c(0.01, 0.01), limits = c(0, 400), breaks = seq(0, 400, by = 50)) +
scale_x_continuous(expand = c(0.01, 0.01), limits = c(0, 7), breaks = c(0, 1, 2, 3, 4, 5, 6, 7)) +
labs(x = "Distance to city center (miles)", y = "Price (US dollars)") +
theme_bg()
p3
p1 | p3
# scatterplot of the whole data set (207 observations)
p4 <- ggplot(data = hotels) +
geom_point(aes(x = distance, y = price), color = color[1], size = 2, shape = 16, alpha = 0.5, show.legend = F, na.rm = TRUE) +
expand_limits(x = 0.01, y = 0.01) +
scale_x_continuous(expand = c(0.01, 0.01), limits = c(0, 7), breaks = seq(0, 7, by = 1)) +
scale_y_continuous(expand = c(0.01, 0.01), limits = c(0, 400), breaks = seq(0, 400, by = 50)) +
labs(x = "Distance to city center (miles)", y = "Price (US dollars)") +
theme_bg()
p4
# non-parametric regression with a step function (4 bins)
hotels <- hotels |> mutate(dist4_s = 1 * as.numeric(hotels$distance >= 1) + 1 * as.numeric(hotels$distance >= 2) + 1 * as.numeric(hotels$distance >= 3) + 1 * as.numeric(hotels$distance >= 4) + 1 * as.numeric(hotels$distance >= 5) + 1 * as.numeric(hotels$distance >= 6))
hotels$xend <- c(hotels$dist4_s + 1)
hotels$yend <- c(hotels$Eprice_cat4)
# plotting non-parametric regression including scatterplot (4 bins)
p5 <- p4 +
geom_segment(data = hotels, aes(x = dist4_s, y = yend, xend = xend, yend = yend), color = color[2], size = 0.7, na.rm = TRUE)
p5
### REGRESSION 3: 7 DISTANCE CATEGORIES
hotels <- hotels |> mutate(dist7_new = 0.5 + 1 * as.numeric(hotels$distance >= 1) + 1 * as.numeric(hotels$distance >= 2) + 1 * as.numeric(hotels$distance >= 3) + 1 * as.numeric(hotels$distance >= 4) + 1 * as.numeric(hotels$distance >= 5) + 1 * as.numeric(hotels$distance >= 6))
dist7_new <- hotels |>
group_by(dist7_new) |>
dplyr::summarize(Eprice_cat7_new = mean(price))
hotels <- left_join(hotels, dist7_new)
hotels |>
group_by(dist7_new) |>
dplyr::summarize(
mean_dist = mean(distance),
sd_dist = sd(distance),
min_dist = min(distance),
max_dist = max(distance),
mean_dist = mean(price),
sd_dist = sd(price),
min_dist = min(price),
max_dist = max(price),
N = n()
)
# non-parametric regression with a step function (7 bins)
hotels <- hotels %>% mutate(dist7_s = 1 * as.numeric(hotels$distance >= 1) + 1 * as.numeric(hotels$distance >= 2) + 1 * as.numeric(hotels$distance >= 3) + 1 * as.numeric(hotels$distance >= 4) + 1 * as.numeric(hotels$distance >= 5) + 1 * as.numeric(hotels$distance >= 6))
hotels$xend <- c(hotels$dist7_s + 1)
hotels$yend <- c(hotels$Eprice_cat7_new)
# plotting non-parametric regression including scatterplot (7 bins)
p6 <- p4 +
geom_segment(data = hotels, aes(x = dist7_s, y = yend, xend = xend, yend = yend), color = color[2], size = 0.7, na.rm = TRUE)
p6
p5 | p6
# LOWESS NONPARAMETRIC REGRESSION
p7 <- p4 +
geom_smooth(aes(x = distance, y = price), method = "loess", se = FALSE)
p7
# CASE STUDY: Finding a Good Deal among Hotels with Simple Regression
# load data
hotels <- read_csv("input/hotels-vienna.csv")
# Apply filters:  3-4 stars, Vienna actual, without extreme value
hotels <- hotels |>
filter(accommodation_type == "Hotel") |>
filter(city_actual == "Vienna") |>
filter(stars >= 3 & stars <= 4) |>
filter(!is.na(stars)) |>
filter(price <= 600)
# plotting scatterplot
p1 <- ggplot(data = hotels) +
geom_point(aes(x = distance, y = price), color = color[1], size = 2, shape = 16, alpha = 0.5, show.legend = F, na.rm = TRUE) +
expand_limits(x = 0.01, y = 0.01) +
scale_x_continuous(expand = c(0.01, 0.01), limits = c(0, 7), breaks = seq(0, 7, by = 1)) +
scale_y_continuous(expand = c(0.01, 0.01), limits = c(0, 400), breaks = seq(0, 400, by = 50)) +
labs(x = "Distance to city center (miles)", y = "Price (US dollars)") +
theme_bg()
p1
# plotting linear regression + lines for averages
p2 <- p1 +
geom_smooth(aes(x = distance, y = price), method = "lm", se = FALSE) +
geom_vline(xintercept = mean(hotels$distance), color = color[3], lty = "dashed", size = 0.3) +
geom_hline(yintercept = mean(hotels$price), color = color[3], lty = "dashed", size = 0.3)
p2
# CASE STUDY: Finding a Good Deal among Hotels with Simple Regression
# load data
hotels <- read_csv("input/hotels-vienna.csv")
# Apply filters:  3-4 stars, Vienna actual, without extreme value
hotels <- hotels |>
filter(accommodation_type == "Hotel") |>
filter(city_actual == "Vienna") |>
filter(stars >= 3 & stars <= 4) |>
filter(!is.na(stars)) |>
filter(price <= 600)
# calculating predicted values and the residuals
regression <- lm(price ~ distance, data = hotels)
hotels$predprice <- predict(regression)
hotels$e <- resid(regression)
# values for annotation
xa<- 2.9
ya<- 208
ym<- 90.24
# plotting the regression line and the residual
p1 <- ggplot(data = hotels, aes(x = distance, y = price)) +
geom_point_da() +
geom_smooth_da(method = "lm") +
annotation_custom(grid.text("Residual", x = 0.48, y = 0.5, gp = gpar(color = "black", fontsize = 4, fontface = "bold"))) +
annotate("pointrange", x = xa, y = ya, ymin = ya, ymax = ya, color = color[3], size = 0.1) +
geom_errorbar(data = subset(hotels, hotels$distance == xa), aes(x = distance, ymin = ym, ymax = ya), width = 0.2, size = 0.2, color = color[1]) +
expand_limits(x = 0.01, y = 0.01) +
scale_x_continuous(expand = c(0.01, 0.01), limits = c(0, 7), breaks = seq(0, 7, by = 1)) +
scale_y_continuous(expand = c(0.01, 0.01), limits = c(0, 400), breaks = seq(0, 400, by = 50)) +
labs(x = "Distance to city center (miles)", y = "Price (US dollars)") +
theme_bg()
p1
# plotting histogram of the residuals
p2 <- ggplot(data = hotels, aes(x = e)) +
geom_histogram(aes(y = (..count..) / sum(..count..)),
binwidth = 20, color = color.outline, fill = theme_colors[1],
size = 0.2, alpha = 0.8, show.legend = F, na.rm = TRUE, boundary = 1
) +
labs(x = "Residuals", y = "Percent") +
scale_x_continuous(limits = c(-100, 300), breaks = seq(-100, 300, by = 100)) +
scale_y_continuous(
expand = c(0.0, 0.0), limits = c(0, 0.3), breaks = seq(0, 0.3, by = 0.05),
labels = scales::percent_format(accuracy = 1)
) +
theme_bg()
p2
# calculating predicted values and the residuals
reg1 <- lm(price ~ distance, data = hotels)
summary(reg1)
# creating new variables
hotels$reg1_resid <- reg1$residuals
hotels$reg1_res <- ifelse(reg1$residuals >= 0, "overpriced", "underpriced")
hotels$reg1_res <- ifelse(hotels$reg1_resid %in% tail(sort(reg1$residuals, decreasing = TRUE), 5), "bottom5",
ifelse(hotels$reg1_resid %in% head(sort(reg1$residuals, decreasing = TRUE), 5), "top5", hotels$reg1_res)
)
# creating new data set
bestdeals <- hotels |>
arrange(e)
bestdeals
# plotting underpriced hotels
p3 <- ggplot(data = hotels, aes(x = distance, y = price)) +
geom_point(
data = filter(hotels, reg1_res == "overpriced"), aes(color = factor(reg1_res)),
size = 1.3, shape = 16, alpha = 0.6, show.legend = F
) +
geom_point(
data = filter(hotels, reg1_res == "underpriced"), aes(color = factor(reg1_res)),
size = 1.3, shape = 16, alpha = 0.6, show.legend = F
) +
geom_point(
data = filter(hotels, reg1_res == "bottom5"), aes(color = factor(reg1_res), fill = factor(reg1_res)),
size = 1.5, shape = 21, alpha = 0.8, show.legend = F
) +
geom_point(
data = filter(hotels, reg1_res == "top5"), aes(color = factor(reg1_res)),
size = 1.3, shape = 16, alpha = 0.6, show.legend = F
) +
geom_smooth_da(method = "lm", size = 1) +
coord_cartesian(xlim = c(0, 7), ylim = c(0, 400)) +
expand_limits(x = 0.01, y = 0.01) +
scale_x_continuous(expand = c(0.01, 0.01), limits = c(0, 7), breaks = seq(0, 7, by = 1)) +
scale_y_continuous(expand = c(0.01, 0.01), limits = c(0, 400), breaks = seq(0, 400, by = 50)) +
labs(x = "Distance to city center (miles)", y = "Price (US dollars)") +
scale_color_manual(
name = "",
values = c(color[1], color[1], color[1], color[1])
) +
scale_fill_manual(name = "", values = c(color[4])) +
geom_segment(aes(x = 2, y = 25, xend = 1.15, yend = 50), arrow = arrow(length = unit(0.1, "cm"))) +
annotate("text", x = 3, y = 25, label = "Most underpriced hotels", size = 3) +
theme_bg() +
theme(axis.text.x = element_text(size = 9)) +
theme(axis.text.y = element_text(size = 9)) +
theme(axis.title.x = element_text(size = 9)) +
theme(axis.title.y = element_text(size = 9))
p3
